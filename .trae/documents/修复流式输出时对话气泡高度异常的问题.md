# 问题分析

通过仔细分析代码，我发现了问题的根本原因：

## 问题根源

1. **文档高度计算时机问题**：在 `AutoResizingTextEdit.adjustHeight()` 中，`document().size().height()` 在HTML内容刚设置时返回的值不准确
2. **异步布局渲染**：Qt的文档布局是异步的，调用 `setHtml()` 后立即获取高度会得到一个很大的初始值
3. **缺少延迟调整**：没有在文档实际渲染完成后再调整高度

## 解决方案

### 方案1：使用QTimer延迟调整高度（推荐）
在 `set_main_content` 方法中，使用 `QTimer.singleShot` 延迟调用 `adjustHeight`，确保文档已经渲染完成。

### 方案2：在adjustHeight中添加保护机制
限制最大高度，防止初始时高度过大。

### 方案3：使用documentSizeChanged信号
连接文档大小变化信号，在文档实际大小确定后再调整高度。

## 具体修改

修改 `ChatBubble.set_main_content` 方法：
```python
def set_main_content(self, text):
    try:
        # ... 原有代码 ...
        self.content_edit.setHtml(style + html_content)
    except Exception:
        self.content_edit.setPlainText(text)
    
    # 延迟调整高度，确保文档已渲染
    QTimer.singleShot(0, self.content_edit.adjustHeight)
```

同时修改 `AutoResizingTextEdit.adjustHeight` 添加最大高度限制：
```python
def adjustHeight(self):
    doc_height = self.document().size().height()
    margins = self.contentsMargins()
    height = int(doc_height + margins.top() + margins.bottom())
    # 限制最大高度，防止初始异常
    height = min(height, 2000)  # 添加最大高度限制
    self.setFixedHeight(max(height, 24))
```